# To take advantage of the windowsImageOverride parameter to target executive order (EO) compliant windows pools such as AzurePipelines-EO, use the build.v1.yml template instead
# You may also need to update your dependsOn clauses associated with that template from ['build'] to ['macOS','linux','windows'] -- or whatever subset of images you use
#
parameters:
  # job parameters
  name: 'build'                                             # the name of the build job for dependency purposes
  displayName: 'Build'                                      # the human name of the job
  timeoutInMinutes: 60                                      # the timeout in minutes
  dependsOn: []                                             # any jobs this job depends on
  initSteps: []                                             # any steps to run before .NET global tools are installed
  preBuildSteps: []                                         # any steps that need to run just before the main compilation starts
  postBuildSteps: []                                        # any steps that need to run just after the main compilation ends
  postDiffBuildSteps: []                                    # any steps that need to run after the API Diff ends
  masterBranchName: 'main'                                  # the "master" branch that should be used - can be something other than "master"
  installAppleCertificates: 'true'                          # whether or not to install the Apple certificates and provisioning profiles
  submodules: false                                         # whether or not to check out submodules
  areaPath: ''                                              # the areaPath to log any issues
  runChecks: 'true'
  continueOnError: 'false'
  publishJob: ''                                            # the job to use as the source of the 'nuget' artifact: '', 'windows', 'macos', 'linux'
  publishOutputSuffix: ''                                   # the artifact suffix to use when publishing the output folder
  signListPath: 'SignList.xml'                              # the path to the SignList.xml to copy into the nuget artifact for signing
  # job software version parameters
  linuxAgentPoolName: 'Azure Pipelines'                     # the name of the Linux VM pool
  macosAgentPoolName: 'Azure Pipelines'                     # the name of the macOS VM pool
  windowsAgentPoolName: 'Azure Pipelines'                   # the name of the Windows VM pool
  linuxImage: ''                                            # the name of the Linux VM image (linuxImage: 'Hosted Ubuntu 1604') 
  macosImage: 'macOS-11'                                    # the name of the macOS VM image
                                                            # 20211121 
                                                            # macOS-latest = macOS-10.15
                                                            # macOS-11 required for XCode 13.1
  windowsImage: 'windows-latest'                            # the name of the Windows VM image
  mono: 'Latest'                                            # the version of mono to use
  xcode: '13.2.1'                                             # the version of Xcode to use
  dotnet: '6.0.300'                                         # the version of .NET Core to use
  dotnetStable: '6.0.300'                                   # the stable version of .NET Core to use
  cake: '2.2.0'                                             # the version of Cake to use
  apiTools: '1.3.4'                                         # the version of the api-tools CLI to use
  xharness: '1.0.0-prerelease.20602.1'
  tools: []                                                 # a list of any additional .NET Core tools needed
  cakeTemplatesBranch: 'main'                               # the branch of XamarinComponents that has the templates
  # build parameters
  buildType: 'basic'                                        # the type of build: 'basic', 'manifest', 'directories', 'none'
  steps: []                                                 # the steps to use when building, typically for 'none'
  verbosity: 'normal'                                       # the build verbosity: 'minimal', 'normal', 'diagnostic'
  configuration: 'Release'                                  # the build configuration: 'Debug', 'Release'
  validPackagePrefixes: [ 'Xamarin', 'Mono' ]               # any NuGet prefixes that should pass validation
  artifactsPath: 'output'                                   # the path to the NuGet packages that need to be signed, verified and published
  # basic cake build parameters
  cakeTarget: 'ci'                                          # [basic] the Cake target to run (defaults to 'ci')
  cakeFile: 'build.cake'                                    # [basic] the path to the build.cake file (can be any filename)
  cakeExtraArgs: ''                                         # [basic] any additional cake CLI arguments
  # manifest-based build parameters
  forceBuild: 'false'                                       # [manifest, directories] whether or not to force the build
  namesFilter: ''                                           # [manifest, directories] the names of the items to build
  targetsFilter: 'ci'                                       # [manifest, directories] the targets of the items to build
  dotnetWorkloadRollbackFile: ''
  dotnetWorkloadSource: ''
  dotnetNuGetOrgSource: ''

jobs:
  - job: ${{ parameters.name }}
    strategy:
      matrix:
        ${{ if ne(parameters.linuxImage, '') }}:
          linux:
            poolName: ${{ parameters.linuxAgentPoolName }}
            imageName: ${{ parameters.linuxImage }}
            runCodeQL: false
        ${{ if ne(parameters.macosImage, '') }}:
          macos:
            poolName: ${{ parameters.macosAgentPoolName }}
            imageName: ${{ parameters.macosImage }}
            classicInstallerUrl: $(LegacyXamarinAndroidPkg)
            runCodeQL: false
        ${{ if ne(parameters.windowsImage, '') }}:
          windows:
            poolName: ${{ parameters.windowsAgentPoolName }}
            imageName: ${{ parameters.windowsImage }}
            classicInstallerUrl: $(LegacyXamarinAndroidVsix)
            runCodeQL: true
    displayName: ${{ parameters.displayName }}
    timeoutInMinutes: ${{ parameters.timeoutInMinutes }}
    continueOnError: ${{ eq(parameters.continueOnError, 'true') }}
    dependsOn: ${{ parameters.dependsOn }}
    variables:
      Codeql.Enabled: $(runCodeQL)
    pool:
      name: $(poolName)
      vmImage: $(imageName)
    steps:
    
      - template: setup-environment.yml
        parameters:
          dotnetVersion: $(DotNetVersion)
          dotnetWorkloadRollbackFile: ${{ parameters.dotnetWorkloadRollbackFile }}
          dotnetWorkloadSource: ${{ parameters.dotnetWorkloadSource }}
          dotnetNuGetOrgSource: ${{ parameters.dotnetNuGetOrgSource }}
          dotnetTools: ${{ parameters.tools }}
          classicInstallerUrl: $(classicInstallerUrl)

      - template: build-and-test.yml
        parameters:
          validPackagePrefixes: ${{ parameters.validPackagePrefixes }}
          artifactsPath: ${{ parameters.artifactsPath }}
          verbosity: ${{ parameters.verbosity }}
          configuration: ${{ parameters.configuration }}

      # after the build is complete
      - pwsh: |
          $srcExists = (Test-Path "${{ parameters.signListPath }}")
          $dstExists = (Test-Path "${{ parameters.artifactsPath }}\SignList.xml")
          if ($srcExists -and !$dstExists) {
            Copy-Item "${{ parameters.signListPath }}" "${{ parameters.artifactsPath }}\SignList.xml"
            Write-Host "Copied ${{ parameters.signListPath }} to ${{ parameters.artifactsPath }}\SignList.xml"
          } elseif (!$srcExists) {
            Write-Host "${{ parameters.signListPath }} did not exist, nothing copied."
          } elseif ($dstExists) {
            Write-Host "${{ parameters.artifactsPath }}\SignList.xml already existed, nothing copied."
          }
        displayName: 'Copy SignList.xml to the nuget artifact'
      - task: PublishBuildArtifacts@1
        displayName: 'Publish artifacts'
        condition: or(eq('${{ parameters.publishJob }}', ''), eq('${{ parameters.publishJob }}', variables['System.JobName']))
        inputs:
          PathToPublish: ${{ parameters.artifactsPath }}
          ArtifactName: nuget
      - task: PublishBuildArtifacts@1
        displayName: 'Publish platform artifacts'
        condition: always()
        inputs:
          PathToPublish: output
          ArtifactName: output-$(System.JobName)${{ parameters.publishOutputSuffix }}
      # run any required checks
      - ${{ if eq(variables['System.TeamProject'], 'devdiv') }}:
        - task: ComponentGovernanceComponentDetection@0
          displayName: 'Run component detection'
          condition: and(always(), eq('refs/heads/${{ parameters.masterBranchName }}', variables['Build.SourceBranch']))
          inputs:
            scanType: 'Register'
            verbosity: 'Verbose'
            alertWarningLevel: 'High'

  - ${{ if and(eq(parameters.runChecks, 'true'), eq(variables['System.TeamProject'], 'devdiv')) }}:
    - job: ${{ parameters.name }}_checks
      displayName: 'Run required code checks'
      condition: eq('refs/heads/${{ parameters.masterBranchName }}', variables['Build.SourceBranch'])
      pool:
        name: 'Hosted Windows 2019 with VS2019'
      steps:
        - pwsh: |
            $repo = "$(Build.Repository.Id)"
            $repo = $repo.Substring($repo.IndexOf("/") + 1)
            $branch = "${{ parameters.masterBranchName }}"
            $CODEBASE_NAME = $repo + "_" + $branch
            echo "Using codebase: $CODEBASE_NAME"
            Write-Host "##vso[task.setvariable variable=CODEBASE_NAME]$CODEBASE_NAME"
        - task: CredScan@2
          displayName: 'Analyze source for credentials'
          inputs:
            toolMajorVersion: 'V2'
        - task: PoliCheck@1
          inputs:
            inputType: 'Basic'
            targetType: 'F'
        - task: SdtReport@1
          displayName: 'Create security analysis report'
          inputs:
            AllTools: false
            APIScan: false
            BinSkim: false
            CodesignValidation: false
            CredScan: true
            FortifySCA: false
            FxCop: false
            ModernCop: false
            MSRD: false
            PoliCheck: true
            RoslynAnalyzers: false
            SDLNativeRules: false
            Semmle: false
            TSLint: false
            ToolLogsNotFoundAction: 'Standard'
        - task: PublishSecurityAnalysisLogs@3
          displayName: 'Publish security analysis logs'
        - task: TSAUpload@1
          continueOnError: true
          inputs:
            tsaVersion: 'TsaV2'
            codebase: 'NewOrUpdate'
            tsaEnvironment: 'PROD'
            codeBaseName: '$(CODEBASE_NAME)'
            notificationAlias: 'xamacomd@microsoft.com'
            notifyAlwaysV2: false
            instanceUrlForTsaV2: 'DEVDIV'
            projectNameDEVDIV: 'DevDiv'
            areaPath: '${{ parameters.areaPath }}'
            iterationPath: 'DevDiv\OneVS'
            uploadAPIScan: false
            uploadBinSkim: false
            uploadCredScan: true
            uploadFortifySCA: false
            uploadFxCop: false
            uploadModernCop: false
            uploadPoliCheck: true
            uploadPREfast: false
            uploadRoslyn: false
            uploadTSLint: false
            uploadAsync: true
